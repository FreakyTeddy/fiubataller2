% Created 2011-05-04 Wed 21:11
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[spanish]{babel}
\usepackage{bookman}
\usepackage[left=2cm,top=3cm,right=2cm,bottom=1cm,head=1.5cm,includefoot]{geometry}
\usepackage{listings}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{comment}
\usepackage{color}
\usepackage{multicol}
\usepackage[table]{xcolor}
\usepackage{ulem}
\usepackage{pdfpages}

\title{Informe}
\author{}
\date{03 Junio 2011}

\begin{document}
%Caratula
\thispagestyle{empty}
  \includepdf[pages=1]{Caratula/Caratula.pdf}

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}
\section{Objetivo}
\label{sec-1}

  Desarrollar un sistema que permita jugar partidas de \textbf{Go}, en un
  tablero reducido y considerando el juego finalizado \textbf{a la primera   muerte} (\emph{capture Go}).

\section{Requerimientos funcionales}
\label{sec-2}

  El sistema debe permitir a dos jugadores humanos en la misma
  computadora jugar entre si. También debe permitir como posibles
  participantes del juego a alguna aplicación externa (como ser
  \textbf{gnugo}). Adicionalmente se deben incluir estrategias de juego para
  que una sola persona pueda desarrollar una partida contra el
  sistema.

\section{Manual de usuario}
\label{sec-3}
\underline{Men\'u de inicio}
\begin{center}
 \includegraphics[scale=0.55]{./Diagramas/captura_fullmoon.png}
\end{center}

En el men\'u de inicio se modifica el tama\~no del tablero para jugar, las estrategias de cada jugador y el nombre de cada jugador.
Para jugar una partida local, luego de seleccionar el tablero y los jugadores, se debe presionar el bot\'on ``Jugar''. Si la estrategia
elegida es ``Humano'', las piedras deben ubicarse en el tablero haciendo click con el bot\'on izquierdo del mouse. \\
Para jugar una partida en red, uno de los jugadores debe crear un servidor mediante el bot\'on ``Crear Partida'' donde se pide
el puerto por el cual esperar una conexi\'on. El cliente luego puede unirse mediante el bot\'on ``Jugar en Red'' especificando
la ip y el puerto del servidor.\\ 
Al jugar en red, el cliente juega con el color negro y el servidor con el color blanco, y es el cliente quien decide
el tama\~no del tablero con el cual jugar.\\

\underline{Tablero del Juego}
\begin{center}
 \includegraphics[scale=0.55]{./Diagramas/captura_tablero.png}
\end{center}


\section{Detalles de implementación}
\label{sec-4}

Estructura general de la soluci\'on:

\begin{center}
 \includegraphics[scale=0.55]{./Diagramas/DiagramaClases/diagrama_de_clases.png}
\end{center}

La clase FullMoonGo posee la l\'ogica de control del juego, seleccionando al jugador correspondiente seg\'un el turno y
detectando el fin de la partida. El tablero es quien verifica la validez de una jugada, encapsulando toda la l\'ogica de cadenas y grados de libertad de una piedra.
Los jugadores ubica una piedra en el tablero, eligiendo su jugada en base a su estrategia asociada, la cual puede ser:
\begin{itemize}
 \item EstrategiaHumano\\
      Representa la jugada realizada por un humano mediante acciones con el mouse sobre la vista.
 \item EstrategiaRemota\\
      Obtiene la jugada realizada por un jugador conectado en red.
 \item	EstrategiaComputadora \\
      Aplica un algoritmo para decidir en qu\'e posici\'on del tablero jugar.
\end{itemize}

Por otro lado, el controlador interact\'ua con la vista, indic\'andole al modelo qu\'e estrategia asignar a cada jugador y
cu\'ando iniciar la partida. En cuanto a una partida remota, el controlador le indica al \'arbitro de la partida (quien maneja la interacci\'on 
con el usuario remoto) cuando crear una conexi\'on, ya sea como cliente o como servidor.

\subsection{Vista}
\label{sec-4.1}

Para implementar el aspecto visual de la aplicaci\'on se uso el la api de Java Swing. Principalmente se utilizaron las clases Frame como contenedor principal y Panel para las distintas pantallas. 
Estas son men\'u de inicio y  la vista del tablero.
En el men\'u se permite elegir la estrategia de cada jugador y se da la opci\'on de crear una partida como servidor o unirse a una partida remota como cliente.
En cuanto a la vista del tablero, \'esta muestra el estado actual del tablero. \\
La vista no posee l\'ogica alguna, sino que detr\'as de cada una hay un controlador que toma la informaci\'on y la utiliza seg\'un corresponda. 
De la misma forma, es el controlador quien espera cambios en el modelo para luego indicarle a la vista que debe actualizarse. Para implementar este mecanismo de comunicaci\'on de se utiliz\'o el patr\'on Observer provisto por la API de Java. Los subscritores son las clases de Control y las clases Observadas son las correspondientes al modelo.

Otro aspecto adicional de las clases de la vista es que manejan la reproducción de los sonidos de posicionamiento de piezas. Siendo uno distinto para cada pieza. Para esto se uso la clase clip que resulta adecuada para una reproducci\'on repetida de sonidos cortos pues los mantiene cargados ( En contraposicion a los Flujos de datos.


\subsection{Protocolo de comunicaciones}
\label{sec-4.2}
  \input{./protocolo_comunicacion.tex}
\subsubsection{EstrategiaRemoto}
\label{sec-4.2.1}

  Para comunicar dos jugadores en red mediante el protocolo, se tiene una clase ``EstrategiaRemota'' la cual
abstrae al motor del juego del intercambio de mensajes entre jugadores. \\
Para notificar y pedir jugadas mediante el protocolo, 
se cuenta con una implementaci\'on que es compatible con el protocolo GTP para el GnuGo, el cual es un 
servidor pasivo que simplemente responde a los comandos enviados por GTP. Por esta raz\'on, implementamos
separadamente la estrategia remota para el servidor y para el cliente, para poder adaptarlos a los mensajes
que deben enviar y los que esperan recibir. \\ 
La convenci\'on de mensajes utilizada es la siguiente: 
\begin{itemize}
 \item EstrategiaRemotaCliente \\
      Se conecta con un servidor y determina el tama\~no del tablero mediante un mensaje \textit{``boardsize''.}\\
      En el turno del jugador remoto, se env\'ia la jugada realizada localmente mediante el mensaje \textit{``play''}, 
      luego se solicita la jugada al servidor remoto mediante un mensaje\textit{ ``genmove''} y se aguarda hasta recibir una respuesta. 
      Cuando esta respuesta llega, el jugador remoto puede poner la piedra recibida en el tablero. 
 \item EstrategiaRemotaServidor\\
      Crea un servidor remoto que espera la conexi\'on de un cliente. El primer mensaje debe ser un \textit{boardize} para determinar el tablero del juego.
      Dado que el servidor es pasivo, cuando es el turno del jugador remoto la estrategia espera la llegada de un mensaje \textit{``genmove'',} 
      el cual contesta con la \'ultima jugada local realizada. Luego, el servidor queda a la espera de la llegada de un mensaje 
     \textit{ ``play''} el cual indica la jugada remota a realizar.
  \item Fin Del Juego\\
      Al finalizar el juego (alguno de los dos jugadores gana), es el cliente quien env\'ia el mensaje de \textit{``quit''} para finalizar
      la comunicaci\'on mediante GTP.
  \item Desconexi\'on\\
      Ante una desconexi\'on repentina de alguno de los dos extremos, la partida finaliza mostrando un mensaje de empate.
\end{itemize}

A continuaci\'on se incluye un diagrama de secuencia describiendo la interacci\'on mencionada.

\begin{center}
 \includegraphics[scale=0.9]{./Diagramas/DiagramaRemoto/secuencia_estrategiaRemoto.png}
\end{center}

La estrategia remota realiza el intercambio de mensajes utilizando la implementaci\'on de la clase ``Remoto'' que corresponda (cliente o servidor).
Adem\'as, funciona como \'arbitro de la partida mediante GTP, coordinando los mensajes administrativos
como son el mensaje de salida (\textit{quit}) y el mensaje indicando el tablero (\textit{boardisze}).

\begin{center}
 \includegraphics[scale=1.0]{./Diagramas/DiagramaRemoto/diagrama_estrategiaRemoto.png}
\end{center}

\newpage

\subsection{Estrategias implementadas}
\label{sec-4.3}

   Actualmente se cuenta con cuatro estrategias de juego que serán
   utilizadas posteriormente para elaborar estrategias mas avanzadas:
\subsubsection{EstrategiaComputadoraAtacar}
\label{sec-4.3.1}

    Esta estrategia intenta ocupar casilleros adyacentes a las cadenas
    con menor grado de libertad del oponente, intentando capturarlas.
\subsubsection{EstrategiaComputadoraDefender}
\label{sec-4.3.2}

    Esta estrategia intenta ocupar casilleros adyacentes a las cadenas
    propias con menor grado de libertad, intentando evitar que sean
    capturadas.
\subsubsection{EstrategiaAtaqueCuidadoso}
\label{sec-4.3.3}

    Esta estrategia es una combinación de las estrategias
    ``EstrategiaComputadoraAtacar'' y
    ``EstrategiaComputadoraDefender''. Primero verifica que las
    cadenas propias no estén en peligro de ser capturadas. Si se
    encuentra una cadena propia en riesgo aplica la estrategia
    ``EstrategiaComputadoraDefender'', en caso contrario aplica
    ``EstrategiaComputadoraAtacar''.
\subsubsection{EstrategiaAtaqueCuidadosoMasInteligente}
\label{sec-4.3.4}

    Similar a la estrategia anterior, pero primero verifica si existe
    alguna cadena del oponente con grado de libertad 1. Si existe,
    verifica que ese grado de libertad no se deba a un ojo. Si no se
    deba a un ojo se procede a capturar al grupo. Si no se cumplen
    estas condiciones, se aplica la estrategia
    ``EstrategiaAtaqueCuidadoso''.

\subsubsection{EstrategiaMiniMax}

   Implementa una estrategia del tipo {\bf MiniMax}. En cada turno,
   arma una lista de todos los casilleros vac\'ios y despliega un
   \'arbol de jugadas por cada posible casillero. La profundidad hasta
   la cual despliega el\'arbol de jugadas es configurable. Al llegar a
   la profundidad deseada, se aplica la funci\'on de evaluaci\'on a
   los tableros resultantes.
   
   La funci\'on de evaluaci\'on tiene en cuenta las siguientes
   variables:
   
   \begin{itemize}
      \item Grados de libertad de MAX: Se cuentan todos los casilleros
        adyacentes a cada cadena de MAX libres (no se cuentan los
        repetidos). Se quiere que sea lo mayor posible.
      \item Cantidad de ojos de MAX
      \item Grados de libertad de la cadena mas corta de MAX: la
        variable a la que se le da m\'as importancia.
      \item Grados de libertad de la cadena mas corta de MIN.
      \item Grados de libertad de la cadena mas larga de MIN.
      \item Ojos de MIN.
   \end{itemize}
   
   Por encima de las variables arriba mencionadas, se encuentra la
   condici\'on de que alguna de alguna de las cadenas de MIN tenga
   grado 1. En ese caso se da por ganada la partida (en esa rama del
   \'arbol de jugadas).

   Al desplegar el \'arbol de jugadas, si en alg\'un nivel todos los
   movimientos son inv\'alidos, se da por finalizada la partida y no
   se sigue avanzando hasta los niveles mas profundos.

\subsubsection{Mejoras posibles}

   La implementaci\'on MiniMax presentada se puede mejorar teniendo en
   cuenta lo siguiente:

   \begin{itemize}
     \item Si se es el primero en jugar, no es necesario descender en
       el \'arbol de jugadas. Ser\'ia conveniente comenzar con jugadas
       precalculadas.
     \item Se tienen en cuenta como jugadas posibles todos los
       casilleros libres del tablero. Se podr\'ia tener en cuenta
       solamente los casilleros adyacentes a todas las cadenas
       presentes en el tablero solamente, limitando as\'i las jugadas,
       pero reduciendo el procesamiento, eventualmente d\'andonos la
       posibilidad de descender un poco mas en el \'arbol de jugadas.
     \item La cantidad de niveles que se baja en el \'arbol de jugadas
       es fija. Se puede parametrizar en funci\'on de las jugadas
       posibles. Al principio de la partida, al haber muchas
       posibilidades se elige por ejemplo descender hasta el nivel 3,
       pero a medida que quedan menos posibilidades (la mitad del
       tablero puede ser un caso) podr\'iamos aumentar un nivel sin
       perder mucha velocidad de respuesta.
     \item La funci\'on de evaluaci\'on actualmente es una suma pesada
       de diferentes variables. Se pueden implementar diferentes
       funciones de evaluaci\'on mas sofisticadas.
   \end{itemize}

\end{document}
